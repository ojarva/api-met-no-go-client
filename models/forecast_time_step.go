// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ForecastTimeStep Forecast for a specific time step
//
// swagger:model ForecastTimeStep
type ForecastTimeStep struct {

	// data
	// Required: true
	Data *ForecastTimeStepData `json:"data"`

	// The time these forecast values are valid for. Timestamp in format YYYY-MM-DDThh:mm:ssZ (ISO 8601)
	// Example: 2019-12-03T14:00:00Z
	// Required: true
	Time *string `json:"time"`
}

// Validate validates this forecast time step
func (m *ForecastTimeStep) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStep) validateData(formats strfmt.Registry) error {

	if err := validate.Required("data", "body", m.Data); err != nil {
		return err
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStep) validateTime(formats strfmt.Registry) error {

	if err := validate.Required("time", "body", m.Time); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this forecast time step based on the context it is used
func (m *ForecastTimeStep) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStep) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	if m.Data != nil {
		if err := m.Data.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ForecastTimeStep) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ForecastTimeStep) UnmarshalBinary(b []byte) error {
	var res ForecastTimeStep
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ForecastTimeStepData Forecast for a specific time
//
// swagger:model ForecastTimeStepData
type ForecastTimeStepData struct {

	// instant
	// Required: true
	Instant *ForecastTimeStepDataInstant `json:"instant"`

	// next 12 hours
	Next12Hours *ForecastTimeStepDataNext12Hours `json:"next_12_hours,omitempty"`

	// next 1 hours
	Next1Hours *ForecastTimeStepDataNext1Hours `json:"next_1_hours,omitempty"`

	// next 6 hours
	Next6Hours *ForecastTimeStepDataNext6Hours `json:"next_6_hours,omitempty"`
}

// Validate validates this forecast time step data
func (m *ForecastTimeStepData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInstant(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNext12Hours(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNext1Hours(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNext6Hours(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStepData) validateInstant(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"instant", "body", m.Instant); err != nil {
		return err
	}

	if m.Instant != nil {
		if err := m.Instant.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "instant")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepData) validateNext12Hours(formats strfmt.Registry) error {
	if swag.IsZero(m.Next12Hours) { // not required
		return nil
	}

	if m.Next12Hours != nil {
		if err := m.Next12Hours.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_12_hours")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepData) validateNext1Hours(formats strfmt.Registry) error {
	if swag.IsZero(m.Next1Hours) { // not required
		return nil
	}

	if m.Next1Hours != nil {
		if err := m.Next1Hours.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_1_hours")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepData) validateNext6Hours(formats strfmt.Registry) error {
	if swag.IsZero(m.Next6Hours) { // not required
		return nil
	}

	if m.Next6Hours != nil {
		if err := m.Next6Hours.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_6_hours")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this forecast time step data based on the context it is used
func (m *ForecastTimeStepData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInstant(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNext12Hours(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNext1Hours(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNext6Hours(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStepData) contextValidateInstant(ctx context.Context, formats strfmt.Registry) error {

	if m.Instant != nil {
		if err := m.Instant.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "instant")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepData) contextValidateNext12Hours(ctx context.Context, formats strfmt.Registry) error {

	if m.Next12Hours != nil {
		if err := m.Next12Hours.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_12_hours")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepData) contextValidateNext1Hours(ctx context.Context, formats strfmt.Registry) error {

	if m.Next1Hours != nil {
		if err := m.Next1Hours.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_1_hours")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepData) contextValidateNext6Hours(ctx context.Context, formats strfmt.Registry) error {

	if m.Next6Hours != nil {
		if err := m.Next6Hours.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_6_hours")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ForecastTimeStepData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ForecastTimeStepData) UnmarshalBinary(b []byte) error {
	var res ForecastTimeStepData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ForecastTimeStepDataInstant Parameters which applies to this exact point in time
//
// swagger:model ForecastTimeStepDataInstant
type ForecastTimeStepDataInstant struct {

	// details
	Details *ForecastTimeInstant `json:"details,omitempty"`
}

// Validate validates this forecast time step data instant
func (m *ForecastTimeStepDataInstant) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStepDataInstant) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.Details) { // not required
		return nil
	}

	if m.Details != nil {
		if err := m.Details.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "instant" + "." + "details")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this forecast time step data instant based on the context it is used
func (m *ForecastTimeStepDataInstant) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStepDataInstant) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.Details != nil {
		if err := m.Details.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "instant" + "." + "details")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ForecastTimeStepDataInstant) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ForecastTimeStepDataInstant) UnmarshalBinary(b []byte) error {
	var res ForecastTimeStepDataInstant
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ForecastTimeStepDataNext12Hours Parameters with validity times over twelve hours. Will not exist for all time steps.
//
// swagger:model ForecastTimeStepDataNext12Hours
type ForecastTimeStepDataNext12Hours struct {

	// details
	// Required: true
	Details *ForecastTimePeriod `json:"details"`

	// summary
	// Required: true
	Summary *ForecastSummary `json:"summary"`
}

// Validate validates this forecast time step data next12 hours
func (m *ForecastTimeStepDataNext12Hours) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStepDataNext12Hours) validateDetails(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"next_12_hours"+"."+"details", "body", m.Details); err != nil {
		return err
	}

	if m.Details != nil {
		if err := m.Details.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_12_hours" + "." + "details")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepDataNext12Hours) validateSummary(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"next_12_hours"+"."+"summary", "body", m.Summary); err != nil {
		return err
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_12_hours" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this forecast time step data next12 hours based on the context it is used
func (m *ForecastTimeStepDataNext12Hours) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStepDataNext12Hours) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.Details != nil {
		if err := m.Details.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_12_hours" + "." + "details")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepDataNext12Hours) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.Summary != nil {
		if err := m.Summary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_12_hours" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ForecastTimeStepDataNext12Hours) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ForecastTimeStepDataNext12Hours) UnmarshalBinary(b []byte) error {
	var res ForecastTimeStepDataNext12Hours
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ForecastTimeStepDataNext1Hours Parameters with validity times over one hour. Will not exist for all time steps.
//
// swagger:model ForecastTimeStepDataNext1Hours
type ForecastTimeStepDataNext1Hours struct {

	// details
	// Required: true
	Details *ForecastTimePeriod `json:"details"`

	// summary
	// Required: true
	Summary *ForecastSummary `json:"summary"`
}

// Validate validates this forecast time step data next1 hours
func (m *ForecastTimeStepDataNext1Hours) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStepDataNext1Hours) validateDetails(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"next_1_hours"+"."+"details", "body", m.Details); err != nil {
		return err
	}

	if m.Details != nil {
		if err := m.Details.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_1_hours" + "." + "details")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepDataNext1Hours) validateSummary(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"next_1_hours"+"."+"summary", "body", m.Summary); err != nil {
		return err
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_1_hours" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this forecast time step data next1 hours based on the context it is used
func (m *ForecastTimeStepDataNext1Hours) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStepDataNext1Hours) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.Details != nil {
		if err := m.Details.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_1_hours" + "." + "details")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepDataNext1Hours) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.Summary != nil {
		if err := m.Summary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_1_hours" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ForecastTimeStepDataNext1Hours) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ForecastTimeStepDataNext1Hours) UnmarshalBinary(b []byte) error {
	var res ForecastTimeStepDataNext1Hours
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ForecastTimeStepDataNext6Hours Parameters with validity times over six hours. Will not exist for all time steps.
//
// swagger:model ForecastTimeStepDataNext6Hours
type ForecastTimeStepDataNext6Hours struct {

	// details
	// Required: true
	Details *ForecastTimePeriod `json:"details"`

	// summary
	// Required: true
	Summary *ForecastSummary `json:"summary"`
}

// Validate validates this forecast time step data next6 hours
func (m *ForecastTimeStepDataNext6Hours) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStepDataNext6Hours) validateDetails(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"next_6_hours"+"."+"details", "body", m.Details); err != nil {
		return err
	}

	if m.Details != nil {
		if err := m.Details.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_6_hours" + "." + "details")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepDataNext6Hours) validateSummary(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"next_6_hours"+"."+"summary", "body", m.Summary); err != nil {
		return err
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_6_hours" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this forecast time step data next6 hours based on the context it is used
func (m *ForecastTimeStepDataNext6Hours) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastTimeStepDataNext6Hours) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.Details != nil {
		if err := m.Details.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_6_hours" + "." + "details")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastTimeStepDataNext6Hours) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.Summary != nil {
		if err := m.Summary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data" + "." + "next_6_hours" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ForecastTimeStepDataNext6Hours) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ForecastTimeStepDataNext6Hours) UnmarshalBinary(b []byte) error {
	var res ForecastTimeStepDataNext6Hours
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
